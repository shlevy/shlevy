{-# LANGUAGE QuantifiedConstraints #-}
{-# LANGUAGE RequiredTypeArguments #-}
{-# LANGUAGE TypeFamilyDependencies #-}

signature CapIO.Core where

import CapIO.Prelim
import Control.Monad.Fix
import Control.Monad.ST
import Data.Coerce
import Data.Kind

type CapIO :: Type -> (Type -> Type)
type family CapIO s = m | m -> s where ..

type role CapabilityData nominal nominal

type CapabilityData :: Type -> Capability -> Type
data CapabilityData s cap

type HasCapability :: Type -> Capability -> Constraint
type family HasCapability s cap where ..

withCapability :: CapabilityData s cap -> ((HasCapability s cap) => x) -> x

capabilityData :: (HasCapability s cap) => CapabilityData s cap

type RootCap = MkCapability Root

type HasRootCap s = HasCapability s RootCap

data Root

class (MonadFix (CapIO s)) => ValidState s where
  forgeRootST :: ST s (CapabilityData s RootCap)
  sudo
    :: forall s'
    -> (m ~ CapIO s, s ~ s')
    => ( ( forall a b. (Coercible a b) => Coercible (m a) (ST s b)
         , forall a b. (s ~ RealWorld, Coercible a b) => Coercible (m a) (IO b)
         )
         => x
       )
    -> (HasRootCap s) => x
  createCapabilityData :: authority -> CapabilityData s (MkCapability authority)

instance ValidState RealWorld

forgeRootIO :: IO (CapabilityData RealWorld RootCap)
